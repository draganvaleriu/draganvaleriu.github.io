<!DOCTYPE html>
<html>
<head>
	<title></title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<link rel="stylesheet" type="text/css" href="style2.css">
	<link rel="stylesheet" type="text/css" href="../page1/style1.css">
	<div class="header">
         <div style="font-size: 40px;">
            <a href=" ../../index.html">
            Grafuri Neorientate
            </a>
         </div>
      </div>
</head>
<body>
 <div id = "page">
         <div id = "menu">
            <ul >
               <li>
                  <div id="term" style="margin-top: 10px;">
                     <p onclick="b(0)">
                        <span>
                        Parcurgerea în adâncime
                        </span>
                     </p>
                  </div>
               </li>
               <li>
                  <div id="grad" onclick="a(getElementById('doi'))"style="margin-top: 10px;" >
                     <p  >
                        <span>
                       Parcurgerea în lățime
                        </span>
                     </p>
                  </div>
               </li>
               <li>
                  <div id="reprez" onclick="a(getElementById('trei'))" style="margin-top: 10px;">
                     <p>
                       Aplicații ale parcurgerii grafurilor
                     </p>
                  </div>
               </li>
            </ul>
         </div>
         <div id = "content">
            <img src="../../img/arrow.png" class="arr" onclick="arrow()">
           <p>
           	Prin parcurgerea unui graf neorientat se înţelege examinarea în mod sistematic a vârfurilor, plecând dintr-un vârf dat <b>start </b>, astfel încât fiecare vârf accesibil din <b>start</b> pe muchii incidente două câte două să fie vizitat o singură dată. Trecerea de la un vârf <b>x</b> la altul se face prin examinarea, într-o anumită ordine a vecinilor săi.
           </p>
            <div id="unu" class="decor"><b>Parcurgerea în adâncime</b></div>
            <p>
            	Parcurgerea în adâncime reprezintă explorarea “naturală” a unui graf neorientat. Este foarte asemănătoare cu modul în care un turist vizitează un oraș în care sunt obiective turistice (vârfurile grafului) și căi de acces între obiective (muchiile). Vizitarea orașului va avea loc din aproape în aproape: se pleacă de la un obiectiv de pornire, se continuă cu un obiectiv învecinat cu acesta, apoi unul învecinat cu al doilea, etc.
            </p>
            <p>
            	<b>Parcurgerea în adâncime se face astfel:</b>
            </p>
            <ul>
            	<li>
            		<p>
            			Se începe cu un vârf inițial <span class="color"> x</span>, care este în acest moment <b>vârf curent</b>.
            		</p>
            	</li>
            	<li>
            		<p>
            			Vârful <span class="color">x</span> se vizitează. Se determină primul său vecin nevizitat <span class="color">y</span> al lui <span class="color">x</span>, care devine vârf curent.
            		</p>
            	</li>
            	<li>
            		<p>
            			Apoi se vizitează primul vecin nevizitat al lui <span class="color">y</span>, şi aşa mai departe, mergând în adâncime, până când ajungem la un vârf care nu mai are vecini nevizitați. Când ajungem într-un astfel de vârf, ne întoarcem la “părintele” acestuia – vârful din care am ajuns în acesta.
            		</p>
            	</li>
            	<li>
            		<p>
            			Dacă acest vârf mai are vecini nevizitați, alegem următorul vecin nevizitat al său și continuam parcurgerea în același mod.
            		</p>
            	</li>
            	<li>
            		<p>
            			Dacă nici acest vârf nu mai are vecini nevizitați, revenim în vârful său părinte și continuăm în același mod, până când toate vârfurile accesibile din vârful de start sunt vizitate.
            		</p>
            	</li>
            </ul>
 
            <p>
            	<b>Observatie:</b>  Dacă graful nu este conex, nu ser vor vizita toate vârfurile. 
            </p>
            <img src="page2_photo/graf.gif"
            width="690" height="345" style="border-radius: 10px;">
            <p > 
            	<b>Parcurgerea din nodul 0 :</b>
            </p>
            <p class="color2" style=" font-size: 30px; display: inline-block; margin-top:10px; 
            padding: 10px;	margin-left: 20px; ">
            	<span class="color" style="white-space: pre;
            	">0  1  3  4  2</span>
            </p>
            <p> 
            	<b>Parcurgerea din nodul 1 :</b>
            </p>
          <p class="color2" style=" font-size: 30px; display: inline-block; margin-top:10px; 
            padding: 10px;	margin-left: 20px; ">
            	<span class="color" style="white-space: pre;
            	">1  0  2  3  4</span>
            </p>
            <p>
            	Pentru implementarea algoritmului se foloseşte un vector caracteristic pentru memorarea faptului că un anume vârf a fost sau nu vizitat, la un anumit moment al parcurgerii:
            </p>
            <ul>
            	<li>
            		<p>
            			<span class="color">v[i] = 0</span>, vârful <span class="color">i</span> nu a fost (încă) vizitat
            		</p>
            	</li>
            	<li>
            		<p>	
            			<span class="color">v[i] = 1</span>, vârful <span class="color">i</span> a fost vizitat
            		</p>
            		</li>

            	</ul>
            	<br>
            	<p>
            			Pentru a determina ordinea în care se parcurg nodurile care pot fi vizitate, se folosește o stivă:
            		</p>
            		<ul>
            			<li>
            				<p>
            					se analizează mereu nodurile adiacent cu nodul din vârful stivei
            				</p>
            			</li>
            			<li>
            				<p>
            					dacă pentru nodul din vârful stivei găsim un vecin nevizitat, adăugăm nodul vecin pe stivă
            				</p>
            			</li>
            			<li>
            				<p>
            					dacă pentru nodul din vârful stivei nu mai găsim niciun vecin nevizitat, îl eliminăm de pe stivă
            				</p>
            			</li>
            		</ul>
            		<br>
            		<p style="margin-top: 40px; margin-left: 30px; font-size: 40px;text-align: center">
            	<b>Implementare C++</b>
            </p>
            <p>
            	<div style=" font-size: 25px;padding:20px ; 	text-align:left;white-space: pre; border-radius: 10px;"  class="color2"> 
void dfs(int k)
{
    v[k] = 1; <span class="comentariu"> //vizitam varful curent x</span>
    for(int i = 0;i < n; i++) <span class="comentariu">//determinam vecinii</span> 
    if(a[k][i] == 1 && v[i] == 0)<span class="comentariu"> //nevizitati ai lui x</span>
    {
      dfs(i); <span class="comentariu">// continuam parcurgerea cu vecinul curent i</span>
    }
}
</div>
            </p>
            <div class="decor" id="doi">
            	 
            		<b>Parcurgerea in latime</b>
            	 
            </div>
            <p>
            	Se parcurge vârful de start, apoi vecinii acestuia, apoi vecinii nevizitați ai acestora, etc, până când sunt vizitate toate vârfurile accesibile. Practic, pentru a stabili ordinea de vizitare se folosește o coadă, iar pentru a stabili dacă un vârf a fost sau nu vizitat se foloseşte un vector caracteristic.
            </p>
            <p>
            	<b>Algoritmul este:</b>
            </p>
            <ul>
            	<li>
            		<p>
            			adaugăm în coadă vârful inițial și îl vizităm
            		</p>
            	</li>
            	<li>
            		<p>
            			cât timp coada este nevidă
            		</p>
            		<ul>
            			<li>
            				<p>
            					extragem un element din coadă
            				</p>
            			</li>
            			<li>
            				<p>
            					determinăm vecinii nevizitați ai vârfului extras, îi vizităm și îi adăugăm în coadă
            				</p>
            			</li>
            			<li>
            				<p>
            					eliminăm elementul din coadă
            				</p>
            			</li>
            		</ul>
            	</li>
            </ul>


			<img src="page2_photo/graf2.gif"
            width="690" height="345" style="border-radius: 10px; margin-top: 30px;">
            <p>
            	<b>
            		Parcurgerea din nodul 0 :
            	</b>
            </p>
           <p class="color2" style=" font-size: 30px; display: inline-block; margin-top:10px; 
            padding: 10px;	margin-left: 20px; ">
            	<span class="color" style="white-space: pre;"> 0  1  2  3  4</span>
            </p>

            <p style="margin-top: 40px; margin-left: 30px; font-size: 40px;text-align: center">
            	<b>Implementare C++</b>
            </p>
            <p>
            	Funcţia de mai jos presupune că un graf cu n vârfuri este memorat prin intermediul matricei de adiacenţă, vectorul <span class="color"> x[]</span> reprezintă coada, vectorul <span class="color">v[]</span>, aceste variabile fiind declarate global. Funcţia returnează numărul de elemente care au fost vizitate.
            </p>
            <div style=" font-size: 25px;padding:20px ; 	text-align:left;white-space: pre; border-radius: 10px;"  class="color2"> 
int bfs(int start)
{
  int i, k, st, dr;
 <span class="comentariu">//initializez coada</span>
  st = dr= 0;
  x[0] = start;
  v[start] = 1;<span class="comentariu">//vizitez varful initial</span>
  while(st <= dr)<span class="comentariu">//cat timp coada nu este vida</span>
  {
    k = x[st];<span class="comentariu">//preiau un element din coada</span>
    for(i = 0;i < n; i++)<span class="comentariu">//parcurg varfurile</span>
      if(v[i] == 0 && a[k][i] == 1)<span class="comentariu">//daca i este vecin </span>
      {                            <span class="comentariu">//cu k si nu este vizitat</span>
        v[i] = 1;<span class="comentariu">//il vizitez</span>
        x[++dr] = i;//<span class="comentariu">il adaug in coada</span>
      }
    st++;<span class="comentariu">//sterg din coada</span>
  }
  return dr;<span class="comentariu">//returnam numarul de varfuri vizitate</span>
}
            </div>
            <div class="decor" id="trei" style="padding-top: 40px;">
            	<b>
            		Aplicații ale parcurgerii grafurilor
            	</b>
            </div>
            <p>
            	Parcurgerea grafurilor neorientate poate fi folosită în rezolvarea unei game largi de probleme: verificarea conexității unui graf, determinarea componentelor conexe ale unui graf, determinarea unor lanțuri în graf, verificarea faptului că un graf este bipartit, etc.
            </p>
            <p style="text-align: center;font-size: 35px">
            	<b>Verificarea conexității</b>
            </p>
            <p>
            	<b>Definiție</b>: Un graf se numește <b>conex</b> dacă între oricare două vârfuri există cel puțin un lanț.
            </p>
            <p>
            	Pentru a verifica dacă un graf este conex, putem folosi oricare metodă de parcurgere, astfel:
            </p>
            <ul>
            	<li>
            		<p>	
            			stabilim un vârf de start
            		</p>
            	</li>
            	<li>
            		<p>
            			realizăm o parcurgere pornind din vârful de start
            		</p>
            	</li>
            	<li>
            		<p>
            			la final verificăm dacă au fost parcurse toate vârfurile, folosind vectorul v de mai sus; în caz afirmativ, graful este conex, altfel graful nu este conex.
            		</p>
            	</li>
            </ul>
            <p style="text-align: center;font-size: 35px">
            	<b>
            		Determinarea componentelor conexe
            	</b>
            </p>
            <p>
            	<b>Definiție</b>: Se numește componentă conexă într-un graf neorientat un subgraf conex și maximal cu această proprietate.
            </p>
            <p>
            	Determinarea componentelor conexe se poate face folosind un algoritm de parcurgere. În vectorul v vârfurile vizitate se vor marca cu valori <span class="color"> 1, 2,</span> etc. Fiecare valoare <span class="color">v[i]</span> reprezintă componenta conexă din care face parte vârful <span class="color">i</span>.
            </p>
            <ul>
            	<li>
            		<p>
            			<span class="color">nrc = 0</span>
            		</p>
            	</li>
            	<li>
            		<p>
            			parcurgem vârfurile
            		</p>
            	</li>
            	<ul>
            		<li>
            			<p>
            				dacă vârful curent nu este vizitat
            			</p>
            		</li>
            		<ul>
            			<li>
            				<p>
            					incrementăm <span class="color">nrc</span> cu <span class="color">1</span>
            				</p>
            			</li>
            			<li>
            				<p>
            					parcurgem graful pornind din vârful curent și marcăm în vectorul <span class="color">v[]</span> vârfurile parcurse cu <span class="color"> nrc</span>
            				</p>
            			</li>
            		</ul>
            	</ul>
            	<li>
            		<p>
            			la final, <span class="color">nrc</span> reprezintă numărul de componente conexe, și toate vârfurile din aceiași componentă sunt marcate în <span class="color">v[]</span> cu aceiași valoare.
            		</p>
            	</li>
            </ul>
           <p style="text-align: center;font-size: 35px">
            	<b>Determinarea unor lanțuri</b>
            </p>
            <p>
            	Pentru a determina un lanț cu extremitățile în nodurile <span class="color">x y</span>, vom realiza o parcurgere pornind de exemplu din <span class="color">x</span>. Dacă se cere un lanț de lungime minimă, vom realiza neapărat o parcurgere în lățime.
            </p>
            <p>
            	Pentru determinarea lanțului vom construi și arborele de parcurgere.
            </p>
            <p>
            	În timpul parcurgerii, când avem nodul curent <span class="color">k</span> și am stabilit că nodul <span class="color">p</span> este adiacent cu <span class="color">k</span> și nevizitat (deci urmează a fi parcurs), vom realiza și operația: <span class="color">t[p] = k</span>;, unde<span class="color"> t</span> este vectorul de tați al arborelui de parcurgere.
            </p>
            <p>
            	Lanțul propriu-zis se va reconstitui din vectorul de tați al arborelui. În secvența de mai jos considerăm că parcurgerea a început din vârful <span class="color">x</span>. Nodurile sunt afișate de la y spre rădăcina <span class="color">x</span>, deci ar putea fi necesar să fie afișate în ordine inversă (de exemplu, să le memorăm într-un tablou și să afișăm invers elementele tabloului).
            </p>
            <div style=" font-size: 25px;padding:20px ; 	text-align:left;white-space: pre; border-radius: 10px;"  class="color2">int p = y;
while(p != 0)
{
    cout << p;
    p = t[p];
} 
</div>
            <p style="text-align: center;font-size: 35px">
            	<b>Verificarea proprietății de graf bipartit</b>
            </p>
            <p>
            	Un graf este bipartit dacă și numai dacă nu are cicluri de lungime impară. Pentru verificare, vom realiza o parcurgere în adâncime pornind dintr-un vârf oarecare, de exemplu <span class="color">1</span>. Pentru a identifica existența unui ciclu de lungime impară, vom marca nodurile vizitate alternativ cu <span class="color">1</span> sau <span class="color">2</span>, astfel:
            </p>

           <ul>
           	<li>
           		 <p>
            	marcăm nodul curent cu valoare <span class="color">x</span>
            	</p>
           	</li>
           	<li>
           		<p>
           			identificăm vecinii nodului curent
           		</p>
           	</li>
           	<ul>
           		<li>
           			<p>
           				dacă nodul vecin nu a fost încă vizitat, îl marcăm cu cealaltă valoare <span class="color">(3-x)</span> și continuăm parcurgerea cu el
           			</p>
           		</li>
           		<li>
           			<p>
           				dacă nodul vecin a fost deja vizitat, acolo se închide un ciclu. Dacă la vizitare acest nod a fost marcat tot cu valoarea  <span class="color">x</span>, atunci acel ciclu are lungime impară, deci graful nu este bipartit.
           			</p>	
           		</li>
           	</ul>
           </ul>

           <p>
           	Dacă graful nu este conex, procedăm similar pentru fiecare componentă conexă.
           </p>
           <p>
           	La final, dacă graful este bipartit, modul în care am marcat nodurile ne dau și cele două submulțimi de noduri ale grafului bipartit. Mai precis, nodurile marcate cu <span class="color">1</span> fac parte din prima submulțime, iar cele marcate cu <span class="color">2</span> fac parte din a doua submulțime.
           </p>

</div>
       
        <div class="bottom">
      <p class="name">
         <b>Dragan Valeriu</b>
      </p>
      <p>
         Colegiul National de Informatica "Spiru Haret"
      </p>
      <p style="margin-bottom: 10px;">Proiect atestat   2020-2021</p>
    </div>
         <script src="javascript1.js"></script>
           <script src="../../javascript/javascript_1.js"></script>
</body>
</html>